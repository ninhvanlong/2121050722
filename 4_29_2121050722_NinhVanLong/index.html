<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Ng·ªçc R·ªìng Z</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#222; font-family: Arial, Helvetica, sans-serif; }
    #game-container { width: 100%; height: 100vh; display:flex; align-items:center; justify-content:center; }
    /* UI overlay */
    .ui {
      position: absolute;
      left: 20px;
      top: 16px;
      color: #fff;
      text-shadow: 0 1px 0 #000;
    }
    .hpbar {
      width: 220px;
      height: 28px;
      background: rgba(0,0,0,0.6);
      border-radius:6px;
      padding:4px;
      box-sizing: border-box;
      display:flex;
      align-items:center;
    }
    .hp-inner {
      height:100%;
      background: linear-gradient(90deg,#ff3b3b,#ffb347);
      border-radius:4px;
      width:100%;
    }
    .hp-text { margin-left:8px; font-weight:700; font-size:14px; color:#fff; text-shadow: 0 1px 0 #000; }
    /* Quickslots bottom */
    .quickslots {
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      bottom:22px;
      display:flex;
      gap:8px;
    }
    .slot {
      width:64px;
      height:48px;
      background: rgba(103, 16, 16, 0.08);
      border: 2px solid rgba(0,0,0,0.5);
      border-radius:6px;
      box-shadow: 0 2px 0 rgba(0,0,0,0.4) inset;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#fff;
      font-weight:700;
      text-shadow: 0 1px 0 #9e0b0b;
    }
    .slot-number { position:absolute; margin-top:30px; font-size:12px; opacity:0.9; }
    /* Boss notice */
    .notice {
      position:absolute;
      right:16px;
      top:16px;
      width:220px;
      background: rgba(0,0,0,0.45);
      color:#fff;
      padding:8px;
      border-radius:8px;
      font-size:13px;
    }
    /* small help */
    .help {
      position:absolute;
      left:20px;
      bottom:22px;
      color:#fff;
      opacity:0.9;
      font-size:13px;
      background: rgba(0,0,0,0.35);
      padding:6px 8px;
      border-radius:6px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game-container"></div>

  <!-- UI overlay -->
  <div class="ui" id="ui-root">
    <div class="hpbar">
      <div id="hpInner" class="hp-inner"></div>
      <div class="hp-text" id="hpText">HP: 100 / 100</div>
    </div>
  </div>

  <div class="notice" id="notice">
    <div style="font-weight:800; margin-bottom:6px;">Th√¥ng b√°o Boss</div>
    <div id="noticeContent">Kh√¥ng c√≥ th√¥ng b√°o</div>
  </div>

  <div class="quickslots" id="quickslots">
    <div class="slot">üçñ<div class="slot-number">1</div></div>
    <div class="slot">üî•<div class="slot-number">2</div></div>
    <div class="slot">üíä<div class="slot-number">3</div></div>
    <div class="slot">‚ú®<div class="slot-number">4</div></div>
    <div class="slot">‚ö°<div class="slot-number">5</div></div>
    <div class="slot">üåÄ<div class="slot-number">6</div></div>
  </div>

  <div class="help">‚Üê ‚Üí di chuy·ªÉn ¬∑ ‚Üë nh·∫£y ¬∑ Space b·∫Øn</div>

<script>
  const config = {
    type: Phaser.AUTO,
    width: 1024,
    height: 600,
    parent: 'game-container',
    backgroundColor: 0x66cdaa,
    physics: {
      default: 'arcade',
      arcade: { gravity: { y: 900 }, debug: false }
    },
    scene: {
      preload: preload,
      create: create,
      update: update
    }
  };

  const game = new Phaser.Game(config);

  let player, cursors, bullets, lastFired = 0;
  let enemies;
  let hp = 100, maxHp = 100;
  let hpInnerEl, hpTextEl, noticeEl;

  function preload() {
    // we create simple colored textures programmatically
    this.textures.generate('player', { data: ['  1111  ', ' 111111 ', '11111111', '11111111', '11111111', ' 111 111', '  11  11'], pixelWidth: 4, palette: { 1: '#ffdd00' } });
    this.textures.generate('enemy',  { data: ['  222  ', ' 222222', '22222222', '22222222', ' 222222', '  222  '], pixelWidth: 4, palette: { 2: '#9b59b6' } });
    this.textures.generate('bullet', { data: ['3'], pixelWidth: 6, palette: { 3: '#00f' }});
    this.load.image('bg', 'https://i.imgur.com/1L3xYkX.jpg'); // fallback scenic bg (hotlink - if blocked, it will still work w/ solid color)
  }

  function create() {
    // background
    this.add.image(512,300,'bg').setDisplaySize(1024,600).setAlpha(0.7);

    // platforms group
    const platforms = this.physics.add.staticGroup();
    // ground
    platforms.create(512, 588, null).setDisplaySize(1024,24).refreshBody().setVisible(false);
    // floating platforms (x,y,width,height) using rectangles
    createPlatform(this, 200, 450, 300, 18);
    createPlatform(this, 540, 380, 260, 18);
    createPlatform(this, 880, 300, 250, 18);
    createPlatform(this, 120, 260, 200, 18);

    // player
    player = this.physics.add.sprite(120, 400, 'player').setScale(1.2);
    player.setCollideWorldBounds(true);
    player.body.setSize(player.width*0.6, player.height*0.8);
    player.speed = 200;
    player.setBounce(0.05);

    // bullets
    bullets = this.physics.add.group({ classType: Phaser.Physics.Arcade.Image, runChildUpdate: true });

    // enemies group
    enemies = this.physics.add.group();
    spawnEnemy(this, 500, 340, 60);
    spawnEnemy(this, 820, 260, 80);
    spawnEnemy(this, 320, 210, 40);

    // collisions
    this.physics.add.collider(player, platforms);
    this.physics.add.collider(enemies, platforms);
    this.physics.add.collider(bullets, platforms, (b) => b.destroy());
    this.physics.add.collider(player, enemies, onPlayerHit, null, this);
    this.physics.add.overlap(bullets, enemies, onBulletHit, null, this);

    // input
    cursors = this.input.keyboard.createCursorKeys();
    this.input.keyboard.on('keydown-SPACE', () => {
      shootBullet(this);
    });

    // small camera follow
    this.cameras.main.startFollow(player, true, 0.1, 0.1);
    this.cameras.main.setBounds(0,0,1024,600);

    // UI hooks
    hpInnerEl = document.getElementById('hpInner');
    hpTextEl  = document.getElementById('hpText');
    noticeEl  = document.getElementById('noticeContent');

    // spawn a timed "boss notice"
    this.time.addEvent({ delay: 12000, loop: false, callback: () => {
      noticeEl.innerText = 'Boss s·∫Ω xu·∫•t hi·ªán ·ªü N√∫i kh√≠ ƒëen sau 1 ph√∫t!';
    }});
  }

  function update(time, delta) {
    // player movement
    if (cursors.left.isDown) {
      player.setVelocityX(-player.speed);
      player.flipX = true;
    } else if (cursors.right.isDown) {
      player.setVelocityX(player.speed);
      player.flipX = false;
    } else {
      player.setVelocityX(0);
    }
    if (cursors.up.isDown && player.body.onFloor()) {
      player.setVelocityY(-420);
    }

    // enemy AI: patrol
    enemies.getChildren().forEach(e => {
      if (!e.active) return;
      if (e.patrolLeft) {
        e.setVelocityX(-e.speed);
        e.flipX = true;
      } else {
        e.setVelocityX(e.speed);
        e.flipX = false;
      }
      // change direction when hits platform edge (simple)
      if (e.x < e.patrolMin) e.patrolLeft = false;
      if (e.x > e.patrolMax) e.patrolLeft = true;
    });

    // update UI HP bar
    const pct = Phaser.Math.Clamp(hp / maxHp, 0, 1);
    hpInnerEl.style.width = `${pct * 100}%`;
    hpTextEl.innerText = `HP: ${hp} / ${maxHp}`;

    if (hp <= 0) {
      hp = 0;
      hpTextEl.innerText = `B·∫°n ƒë√£ ch·∫øt`;
      // freeze game
      this.scene.pause();
      setTimeout(() => {
        alert('B·∫°n ƒë√£ thua. T·∫£i l·∫°i trang ƒë·ªÉ ch∆°i l·∫°i.');
      }, 100);
    }
  }

  // ---------- helpers ----------
  function createPlatform(scene, x, y, width, height) {
    const g = scene.add.graphics();
    g.fillStyle(0x2f6f4f, 1);
    g.fillRoundedRect(-width/2, -height/2, width, height, 8);
    const texKey = 'plat-' + x + '-' + y;
    g.generateTexture(texKey, width, height);
    g.destroy();
    const p = scene.physics.add.staticImage(x, y, texKey);
    p.setDisplaySize(width, height);
    p.refreshBody();
    return p;
  }

  function spawnEnemy(scene, x, y, range) {
    const e = enemies.create(x, y, 'enemy').setScale(1);
    e.setCollideWorldBounds(true);
    e.setBounce(0.1);
    e.body.setSize(e.width*0.6, e.height*0.8);
    e.hp = 30;
    e.speed = 60;
    e.patrolMin = x - range;
    e.patrolMax = x + range;
    e.patrolLeft = true;
    return e;
  }

  function shootBullet(scene) {
    // rate limit
    const now = scene.time.now;
    if (now - lastFired < 300) return;
    lastFired = now;

    const dir = player.flipX ? -1 : 1;
    const b = bullets.create(player.x + dir*30, player.y - 6, 'bullet');
    b.setVelocityX(600 * dir);
    b.setVelocityY(0);
    b.setCollideWorldBounds(false);
    b.body.allowGravity = false;
    // destroy after 2s
    scene.time.delayedCall(2000, () => { if (b && b.active) b.destroy(); });
  }

  function onBulletHit(bullet, enemy) {
    if (!enemy.active) return;
    bullet.destroy();
    enemy.hp -= 12;
    // knockback
    const kb = (bullet.body.velocity.x > 0) ? 40 : -40;
    enemy.setVelocityX(kb);
    // flash
    enemy.setTint(0xff0000);
    setTimeout(() => { if (enemy && enemy.active) enemy.clearTint(); }, 80);

    if (enemy.hp <= 0) {
      // spawn drop (healing meat)
      dropHeal(enemy.scene, enemy.x, enemy.y);
      enemy.destroy();
      // small XP or text
      const txt = enemy.scene.add.text(enemy.x, enemy.y - 30, '+10', { font: '16px Arial', fill:'#fff' }).setDepth(10);
      enemy.scene.tweens.add({ targets: txt, y: txt.y - 30, alpha:0, duration:800, onComplete: ()=>txt.destroy() });
    }
  }

  function onPlayerHit(playerSprite, enemy) {
    // take damage and push back
    const dmg = 10;
    hp = Math.max(0, hp - dmg);
    playerSprite.setTint(0xff4444);
    setTimeout(() => { if (playerSprite) playerSprite.clearTint(); }, 180);

    // knockback
    const dir = (playerSprite.x < enemy.x) ? -1 : 1;
    playerSprite.setVelocityX(-dir * 180);
  }

  function dropHeal(scene, x, y) {
    const heal = scene.add.text(x, y, 'üçñ', { font: '22px Arial' });
    heal.setOrigin(0.5);
    scene.physics.add.existing(heal);
    heal.body.setVelocityY(-120);
    heal.body.setVelocityX(Phaser.Math.Between(-40,40));
    heal.body.setBounce(0.6);
    heal.body.setCollideWorldBounds(true);
    // collect when player overlaps
    scene.physics.add.overlap(player, heal, () => {
      hp = Math.min(maxHp, hp + 20);
      heal.destroy();
    });
    // auto destroy after 8s
    scene.time.delayedCall(8000, () => { if (heal && heal.active) heal.destroy(); });
  }
</script>
</body>
</html>
